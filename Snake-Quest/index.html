<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snake Quest: The Living Circuit</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #050810;
            --bg-surface: #0a0f18;
            --grid-line: #0f1520;
            --snake-head: #00ffaa;
            --snake-body: #00cc88;
            --snake-glow: rgba(0, 255, 170, 0.6);
            --snake-starving: #ff5555;
            --snake-satiated: #55ff88;
            --food-core: #ffcc00;
            --food-glow: rgba(255, 200, 0, 0.8);
            --toxic-waste: #cc44ff;
            --inert-waste: #445566;
            --frenzy-pulse: #ff3333;
            --text-primary: #e8f0ff;
            --text-dim: #556688;
            --text-glow: rgba(0, 255, 170, 0.4);
            --ui-border: rgba(0, 255, 170, 0.15);
            --ui-bg: rgba(5, 8, 16, 0.85);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: var(--bg-deep);
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(ellipse at 20% 80%, rgba(0, 100, 150, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(100, 0, 150, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(0, 50, 100, 0.05) 0%, transparent 70%);
            pointer-events: none;
            z-index: 0;
        }

        #game-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            z-index: 1;
        }

        /* Petri Dish Frame - Enhanced */
        #petri-dish {
            position: relative;
            border-radius: 50%;
            box-shadow:
                inset 0 0 80px rgba(0, 255, 170, 0.03),
                inset 0 0 150px rgba(0, 0, 0, 0.9),
                0 0 60px rgba(0, 255, 170, 0.08),
                0 0 120px rgba(0, 100, 150, 0.1),
                0 8px 40px rgba(0, 0, 0, 0.6);
            background:
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.015) 0%, transparent 40%),
                radial-gradient(circle at 75% 75%, rgba(0, 0, 0, 0.3) 0%, transparent 40%),
                var(--bg-surface);
            overflow: hidden;
            transition: box-shadow 0.3s ease;
        }

        #petri-dish::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            border: 3px solid rgba(0, 255, 170, 0.1);
            pointer-events: none;
            transition: border-color 0.3s ease;
        }

        #petri-dish::after {
            content: '';
            position: absolute;
            top: 5%;
            left: 10%;
            width: 30%;
            height: 15%;
            background: linear-gradient(135deg, rgba(255,255,255,0.04) 0%, transparent 100%);
            border-radius: 50%;
            pointer-events: none;
            transform: rotate(-20deg);
        }

        #petri-dish.frenzy {
            animation: frenzyPulse 0.2s ease-in-out infinite;
            box-shadow:
                inset 0 0 80px rgba(255, 50, 50, 0.15),
                inset 0 0 150px rgba(0, 0, 0, 0.9),
                0 0 80px rgba(255, 50, 50, 0.25),
                0 0 150px rgba(255, 0, 0, 0.15),
                0 8px 40px rgba(0, 0, 0, 0.6);
        }

        #petri-dish.frenzy::before {
            border-color: rgba(255, 50, 50, 0.4);
            animation: frenzyBorder 0.2s ease-in-out infinite;
        }

        @keyframes frenzyPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.005); }
        }

        @keyframes frenzyBorder {
            0%, 100% { border-color: rgba(255, 50, 50, 0.3); }
            50% { border-color: rgba(255, 50, 50, 0.6); }
        }

        #game-canvas {
            display: block;
            border-radius: 50%;
        }

        /* HUD - Enhanced */
        #hud {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }

        .hud-panel {
            background: var(--ui-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--ui-border);
            border-radius: 16px;
            padding: 14px 20px;
            min-width: 110px;
            box-shadow:
                0 4px 20px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.05);
        }

        .hud-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-dim);
            margin-bottom: 6px;
        }

        .hud-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.6rem;
            font-weight: 900;
            color: var(--snake-head);
            text-shadow: 0 0 20px var(--text-glow);
        }

        /* Hunger Bar - Enhanced */
        #hunger-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 220px;
            z-index: 10;
        }

        #hunger-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--text-dim);
            text-align: center;
            margin-bottom: 8px;
        }

        #hunger-bar-bg {
            width: 100%;
            height: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            overflow: hidden;
            border: 1px solid var(--ui-border);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #hunger-bar {
            height: 100%;
            width: 50%;
            background: linear-gradient(90deg,
                #22ff88 0%,
                #88ff44 25%,
                #ffcc00 50%,
                #ff8800 75%,
                #ff4444 100%);
            border-radius: 5px;
            transition: width 0.2s ease;
            box-shadow: 0 0 10px rgba(255, 200, 0, 0.3);
        }

        #hunger-status {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            font-weight: 700;
            text-align: center;
            margin-top: 6px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Overlay Screens - Enhanced */
        .overlay-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, rgba(5, 8, 16, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
            z-index: 100;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .overlay-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .game-title {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(1.8rem, 6vw, 3rem);
            font-weight: 900;
            color: var(--snake-head);
            text-shadow:
                0 0 30px var(--snake-glow),
                0 0 60px rgba(0, 255, 170, 0.3);
            margin-bottom: 8px;
            text-align: center;
            letter-spacing: 0.05em;
        }

        .game-subtitle {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin-bottom: 50px;
            text-align: center;
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }

        .instructions {
            max-width: 340px;
            text-align: center;
            margin-bottom: 40px;
            line-height: 1.7;
            color: var(--text-dim);
            font-size: 0.8rem;
        }

        .mechanic-list {
            text-align: left;
            margin: 20px 0;
            padding: 0 15px;
        }

        .mechanic-item {
            margin: 14px 0;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }

        .mechanic-icon {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            flex-shrink: 0;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }

        .mechanic-icon.hunger {
            background: linear-gradient(135deg, #22ff88, #ff4444);
        }
        .mechanic-icon.shed {
            background: linear-gradient(135deg, var(--toxic-waste), var(--inert-waste));
        }
        .mechanic-icon.prey {
            background: radial-gradient(circle at 30% 30%, #ffee88, var(--food-core));
            animation: preyPulse 1s ease-in-out infinite;
        }
        .mechanic-icon.endless {
            background: linear-gradient(135deg, #4488ff, #8844ff);
        }

        @keyframes preyPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .mechanic-item strong {
            color: var(--food-core);
        }

        .start-btn {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            font-weight: 700;
            padding: 18px 55px;
            background: linear-gradient(135deg, var(--snake-head), var(--snake-body));
            border: none;
            border-radius: 35px;
            color: var(--bg-deep);
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow:
                0 4px 25px rgba(0, 255, 170, 0.4),
                inset 0 2px 0 rgba(255, 255, 255, 0.2);
            pointer-events: auto;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .start-btn:hover {
            transform: scale(1.08) translateY(-2px);
            box-shadow:
                0 8px 40px rgba(0, 255, 170, 0.5),
                inset 0 2px 0 rgba(255, 255, 255, 0.2);
        }

        .start-btn:active {
            transform: scale(1.02);
        }

        .final-score {
            font-family: 'Orbitron', sans-serif;
            font-size: 4rem;
            font-weight: 900;
            color: var(--food-core);
            margin: 25px 0;
            text-shadow: 0 0 40px var(--food-glow);
        }

        .high-score {
            font-size: 0.9rem;
            color: var(--text-dim);
            margin-bottom: 35px;
        }

        .high-score span {
            color: var(--snake-head);
            font-weight: 700;
        }

        .controls-hint {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: var(--text-dim);
            text-align: center;
            letter-spacing: 0.1em;
        }

        /* Mode badge */
        .mode-badge {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(100, 50, 255, 0.2);
            border: 1px solid rgba(100, 50, 255, 0.4);
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 0.65rem;
            color: #aa88ff;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            font-weight: 700;
        }

        /* Responsive */
        @media (max-width: 600px) {
            #hud {
                top: 10px;
                left: 10px;
                right: 10px;
            }

            .hud-panel {
                padding: 10px 14px;
                min-width: 75px;
                border-radius: 12px;
            }

            .hud-value {
                font-size: 1.2rem;
            }

            #hunger-container {
                width: 170px;
                bottom: 12px;
            }

            .instructions {
                font-size: 0.7rem;
                padding: 0 15px;
            }

            .mechanic-item {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="petri-dish">
            <canvas id="game-canvas"></canvas>
        </div>

        <div class="mode-badge">Endless Mode</div>

        <div id="hud">
            <div class="hud-panel">
                <div class="hud-label">Score</div>
                <div class="hud-value" id="score-display">0</div>
            </div>
            <div class="hud-panel">
                <div class="hud-label">Length</div>
                <div class="hud-value" id="length-display">3</div>
            </div>
        </div>

        <div id="hunger-container">
            <div id="hunger-label">Metabolism</div>
            <div id="hunger-bar-bg">
                <div id="hunger-bar"></div>
            </div>
            <div id="hunger-status">Balanced</div>
        </div>

        <!-- Start Screen -->
        <div class="overlay-screen" id="start-screen">
            <div class="game-title">Snake Quest</div>
            <div class="game-subtitle">The Living Circuit</div>

            <div class="instructions">
                <div class="mechanic-list">
                    <div class="mechanic-item">
                        <div class="mechanic-icon endless"></div>
                        <div><strong>Endless Mode:</strong> No walls! Wrap around the edges. Only die from collisions.</div>
                    </div>
                    <div class="mechanic-item">
                        <div class="mechanic-icon hunger"></div>
                        <div><strong>Metabolism:</strong> Hunger affects speed. Starving = fast. Satiated = slow.</div>
                    </div>
                    <div class="mechanic-item">
                        <div class="mechanic-icon prey"></div>
                        <div><strong>Panicked Prey:</strong> Food cells are terrified and flee aggressively!</div>
                    </div>
                    <div class="mechanic-item">
                        <div class="mechanic-icon shed"></div>
                        <div><strong>Shedding:</strong> Every 10 length, shed toxic or inert waste.</div>
                    </div>
                </div>
            </div>

            <button class="start-btn" id="start-btn">Begin Hunt</button>
            <div class="controls-hint">Arrow Keys / WASD / Swipe</div>
        </div>

        <!-- Game Over Screen -->
        <div class="overlay-screen hidden" id="gameover-screen">
            <div class="game-title">Circuit Broken</div>
            <div class="game-subtitle">The organism has perished</div>
            <div class="final-score" id="final-score">0</div>
            <div class="high-score">Best Run: <span id="high-score">0</span></div>
            <button class="start-btn" id="restart-btn">Hunt Again</button>
        </div>
    </div>

    <script>
        // ============================================
        // SNAKE QUEST: THE LIVING CIRCUIT
        // Endless Mode - Enhanced Aesthetics
        // ============================================

        (function() {
            'use strict';

            // -----------------------------------------
            // CONFIGURATION
            // -----------------------------------------
            const CONFIG = {
                // Grid
                TILE_SIZE: 18,
                GRID_PADDING: 1,

                // Snake
                INITIAL_LENGTH: 3,
                BASE_SPEED: 110,
                STARVING_SPEED: 55,
                FRENZY_SPEED: 35,

                // Metabolism
                HUNGER_DECAY: 0.4,
                HUNGER_RESTORE: 35,
                FRENZY_THRESHOLD: 90,
                MAX_HUNGER: 100,

                // Shedding
                SHED_INTERVAL: 10,
                WASTE_DECAY_TIME: 25000,
                WASTE_MIN_SIZE: 0.25,

                // AGGRESSIVE Reactive prey
                PREY_ESCAPE_RADIUS: 6,      // Increased from 3
                PREY_ESCAPE_CHANCE: 0.95,   // Increased from 0.7
                PREY_PANIC_RADIUS: 3,       // Extra panic zone
                PREY_MULTI_JUMP_CHANCE: 0.4, // Chance to jump 2 tiles
                PREY_COOLDOWN: 60,          // Reduced from 200ms

                // Particles
                MAX_PARTICLES: 150,
                PARTICLE_LIFETIME: 1200,

                // Ambient particles
                AMBIENT_PARTICLES: 40,

                // Nutrient aura
                NUTRIENT_RADIUS: 4,
                FOOD_ATTRACT_CHANCE: 0.35,

                // Visual
                TRAIL_LENGTH: 8,
                GLOW_INTENSITY: 1.2,
            };

            // -----------------------------------------
            // GAME STATE
            // -----------------------------------------
            let canvas, ctx;
            let gameWidth, gameHeight;
            let gridWidth, gridHeight;
            let centerX, centerY, dishRadius;
            let lastMoveTime = 0;
            let isPlaying = false;

            // Snake
            let snake = [];
            let snakeTrail = [];
            let direction = { x: 1, y: 0 };
            let nextDirection = { x: 1, y: 0 };
            let hunger = 50;
            let lastShedLength = 0;
            let digestionQueue = [];

            // Food
            let food = null;
            let foodEscapeCooldown = 0;
            let foodPanic = 0;  // Panic intensity

            // Waste
            let wasteObstacles = [];

            // Particles
            let particles = [];
            let ambientParticles = [];

            // Score
            let score = 0;
            let highScore = parseInt(localStorage.getItem('snakeQuestHighScore')) || 0;

            // Input
            let touchStartX = 0;
            let touchStartY = 0;

            // Screen shake
            let screenShake = 0;

            // -----------------------------------------
            // INITIALIZATION
            // -----------------------------------------
            function init() {
                canvas = document.getElementById('game-canvas');
                ctx = canvas.getContext('2d');

                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);

                document.addEventListener('keydown', handleKeyDown);
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

                document.getElementById('start-btn').addEventListener('click', startGame);
                document.getElementById('restart-btn').addEventListener('click', startGame);

                document.getElementById('high-score').textContent = highScore;

                initAmbientParticles();
                requestAnimationFrame(renderLoop);
            }

            function resizeCanvas() {
                const container = document.getElementById('game-container');
                const petriDish = document.getElementById('petri-dish');

                const maxSize = Math.min(
                    container.clientWidth - 40,
                    container.clientHeight - 180,
                    620
                );

                const size = Math.floor(maxSize / CONFIG.TILE_SIZE) * CONFIG.TILE_SIZE;

                canvas.width = size;
                canvas.height = size;
                gameWidth = size;
                gameHeight = size;

                gridWidth = Math.floor(size / CONFIG.TILE_SIZE);
                gridHeight = Math.floor(size / CONFIG.TILE_SIZE);

                centerX = gridWidth / 2;
                centerY = gridHeight / 2;
                dishRadius = Math.min(gridWidth, gridHeight) / 2 - CONFIG.GRID_PADDING;

                petriDish.style.width = size + 'px';
                petriDish.style.height = size + 'px';

                initAmbientParticles();
            }

            function initAmbientParticles() {
                ambientParticles = [];
                for (let i = 0; i < CONFIG.AMBIENT_PARTICLES; i++) {
                    ambientParticles.push(createAmbientParticle());
                }
            }

            function createAmbientParticle() {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * dishRadius * CONFIG.TILE_SIZE * 0.9;
                return {
                    x: gameWidth / 2 + Math.cos(angle) * dist,
                    y: gameHeight / 2 + Math.sin(angle) * dist,
                    vx: (Math.random() - 0.5) * 0.3,
                    vy: (Math.random() - 0.5) * 0.3,
                    size: 1 + Math.random() * 2,
                    alpha: 0.1 + Math.random() * 0.3,
                    pulse: Math.random() * Math.PI * 2
                };
            }

            // -----------------------------------------
            // GAME CONTROL
            // -----------------------------------------
            function startGame() {
                snake = [];
                snakeTrail = [];
                wasteObstacles = [];
                particles = [];
                digestionQueue = [];
                score = 0;
                hunger = 50;
                lastShedLength = 0;
                direction = { x: 1, y: 0 };
                nextDirection = { x: 1, y: 0 };
                screenShake = 0;
                foodPanic = 0;

                const cx = Math.floor(gridWidth / 2);
                const cy = Math.floor(gridHeight / 2);
                for (let i = 0; i < CONFIG.INITIAL_LENGTH; i++) {
                    snake.push({ x: cx - i, y: cy });
                }

                spawnFood();
                updateHUD();

                document.getElementById('start-screen').classList.add('hidden');
                document.getElementById('gameover-screen').classList.add('hidden');
                document.getElementById('petri-dish').classList.remove('frenzy');

                isPlaying = true;
                lastMoveTime = performance.now();
            }

            function gameOver() {
                isPlaying = false;
                document.getElementById('petri-dish').classList.remove('frenzy');
                screenShake = 15;

                if (score > highScore) {
                    highScore = score;
                    localStorage.setItem('snakeQuestHighScore', highScore);
                }

                document.getElementById('final-score').textContent = score;
                document.getElementById('high-score').textContent = highScore;

                setTimeout(() => {
                    document.getElementById('gameover-screen').classList.remove('hidden');
                }, 500);
            }

            // -----------------------------------------
            // INPUT
            // -----------------------------------------
            function handleKeyDown(e) {
                if (!isPlaying) return;

                const key = e.key.toLowerCase();
                let newDir = null;

                if ((key === 'arrowup' || key === 'w') && direction.y !== 1) {
                    newDir = { x: 0, y: -1 };
                } else if ((key === 'arrowdown' || key === 's') && direction.y !== -1) {
                    newDir = { x: 0, y: 1 };
                } else if ((key === 'arrowleft' || key === 'a') && direction.x !== 1) {
                    newDir = { x: -1, y: 0 };
                } else if ((key === 'arrowright' || key === 'd') && direction.x !== -1) {
                    newDir = { x: 1, y: 0 };
                }

                if (newDir) {
                    nextDirection = newDir;
                    e.preventDefault();
                }
            }

            function handleTouchStart(e) {
                e.preventDefault();
                touchStartX = e.touches[0].clientX;
                touchStartY = e.touches[0].clientY;
            }

            function handleTouchEnd(e) {
                e.preventDefault();
                if (!isPlaying) return;

                const dx = e.changedTouches[0].clientX - touchStartX;
                const dy = e.changedTouches[0].clientY - touchStartY;

                if (Math.abs(dx) < 30 && Math.abs(dy) < 30) return;

                let newDir = null;
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0 && direction.x !== -1) newDir = { x: 1, y: 0 };
                    else if (dx < 0 && direction.x !== 1) newDir = { x: -1, y: 0 };
                } else {
                    if (dy > 0 && direction.y !== -1) newDir = { x: 0, y: 1 };
                    else if (dy < 0 && direction.y !== 1) newDir = { x: 0, y: -1 };
                }

                if (newDir) nextDirection = newDir;
            }

            // -----------------------------------------
            // GAME LOGIC
            // -----------------------------------------
            function getCurrentSpeed() {
                if (hunger >= CONFIG.FRENZY_THRESHOLD) return CONFIG.FRENZY_SPEED;
                const t = hunger / 100;
                return CONFIG.BASE_SPEED - (CONFIG.BASE_SPEED - CONFIG.STARVING_SPEED) * t;
            }

            function update(deltaTime) {
                if (!isPlaying) return;

                // Hunger
                hunger = Math.min(CONFIG.MAX_HUNGER, hunger + CONFIG.HUNGER_DECAY * deltaTime / 1000);

                // Frenzy visual
                const petriDish = document.getElementById('petri-dish');
                if (hunger >= CONFIG.FRENZY_THRESHOLD) {
                    petriDish.classList.add('frenzy');
                } else {
                    petriDish.classList.remove('frenzy');
                }

                // Food escape cooldown
                if (foodEscapeCooldown > 0) foodEscapeCooldown -= deltaTime;

                // Food panic decay
                if (foodPanic > 0) foodPanic -= deltaTime / 500;

                // Digestion
                digestionQueue.forEach(d => d.progress += deltaTime / 400);
                digestionQueue = digestionQueue.filter(d => d.progress < snake.length);

                // Waste decay
                const now = performance.now();
                wasteObstacles.forEach(w => {
                    const age = now - w.createdAt;
                    w.scale = Math.max(CONFIG.WASTE_MIN_SIZE, 1 - (age / CONFIG.WASTE_DECAY_TIME) * (1 - CONFIG.WASTE_MIN_SIZE));
                });

                // Particles
                particles = particles.filter(p => {
                    p.life -= deltaTime;
                    p.x += p.vx * deltaTime / 16;
                    p.y += p.vy * deltaTime / 16;
                    p.vx *= 0.97;
                    p.vy *= 0.97;
                    return p.life > 0;
                });

                // Screen shake decay
                if (screenShake > 0) screenShake *= 0.9;

                // Move snake
                const speed = getCurrentSpeed();
                if (now - lastMoveTime >= speed) {
                    moveSnake();
                    lastMoveTime = now;
                }

                // AGGRESSIVE prey escape
                if (food && foodEscapeCooldown <= 0) {
                    const head = snake[0];
                    const dist = Math.abs(head.x - food.x) + Math.abs(head.y - food.y);

                    if (dist <= CONFIG.PREY_PANIC_RADIUS) {
                        // Panic mode - always escape, possibly multiple times
                        foodPanic = 1;
                        escapePrey(true);
                        if (Math.random() < 0.5) escapePrey(true);
                    } else if (dist <= CONFIG.PREY_ESCAPE_RADIUS && Math.random() < CONFIG.PREY_ESCAPE_CHANCE) {
                        escapePrey(false);
                    }
                }

                updateHUD();
            }

            function moveSnake() {
                direction = nextDirection;

                const head = snake[0];
                let newHead = {
                    x: head.x + direction.x,
                    y: head.y + direction.y
                };

                // ENDLESS: Wrap around edges
                const distFromCenter = Math.sqrt(
                    Math.pow(newHead.x - centerX + 0.5, 2) +
                    Math.pow(newHead.y - centerY + 0.5, 2)
                );

                if (distFromCenter >= dishRadius) {
                    // Wrap to opposite side
                    const angle = Math.atan2(newHead.y - centerY, newHead.x - centerX);
                    newHead.x = Math.floor(centerX - Math.cos(angle) * (dishRadius - 2));
                    newHead.y = Math.floor(centerY - Math.sin(angle) * (dishRadius - 2));
                }

                // Self collision
                for (let i = 1; i < snake.length; i++) {
                    if (snake[i].x === newHead.x && snake[i].y === newHead.y) {
                        gameOver();
                        return;
                    }
                }

                // Waste collision
                for (const waste of wasteObstacles) {
                    if (waste.x === newHead.x && waste.y === newHead.y) {
                        if (hunger >= CONFIG.FRENZY_THRESHOLD && !waste.consumed) {
                            waste.consumed = true;
                            spawnParticles(waste.x, waste.y, waste.toxic ? '#cc44ff' : '#556677', 12);
                            screenShake = 5;
                            continue;
                        }
                        gameOver();
                        return;
                    }
                }
                wasteObstacles = wasteObstacles.filter(w => !w.consumed);

                // Add trail
                snakeTrail.unshift({ x: head.x, y: head.y, age: 0 });
                if (snakeTrail.length > CONFIG.TRAIL_LENGTH) snakeTrail.pop();
                snakeTrail.forEach(t => t.age++);

                // Add head
                snake.unshift(newHead);

                // Food collision
                if (food && newHead.x === food.x && newHead.y === food.y) {
                    eatFood();
                } else {
                    snake.pop();
                }

                // Shedding
                const currentLength = snake.length;
                if (Math.floor(currentLength / CONFIG.SHED_INTERVAL) > Math.floor(lastShedLength / CONFIG.SHED_INTERVAL)) {
                    if (currentLength >= CONFIG.SHED_INTERVAL) shedWaste();
                }
                lastShedLength = currentLength;
            }

            function eatFood() {
                score += 10;
                hunger = Math.max(0, hunger - CONFIG.HUNGER_RESTORE);
                digestionQueue.push({ segment: 0, progress: 0 });
                spawnParticles(food.x, food.y, '#ffcc00', 20);
                screenShake = 8;
                spawnFood();
            }

            function shedWaste() {
                if (snake.length < 2) return;

                const tail = snake.pop();
                const isToxic = hunger > 50;

                wasteObstacles.push({
                    x: tail.x,
                    y: tail.y,
                    toxic: isToxic,
                    createdAt: performance.now(),
                    scale: 1
                });

                spawnParticles(tail.x, tail.y, isToxic ? '#cc44ff' : '#556677', 15);
            }

            function escapePrey(panic) {
                if (!food) return;

                const head = snake[0];
                let dx = food.x - head.x;
                let dy = food.y - head.y;

                // Determine escape direction
                let escapeX = 0, escapeY = 0;

                if (panic) {
                    // Panic: move diagonally away + randomness
                    escapeX = dx > 0 ? 1 : -1;
                    escapeY = dy > 0 ? 1 : -1;
                    if (Math.random() < 0.3) escapeX = (Math.random() < 0.5 ? 1 : -1);
                    if (Math.random() < 0.3) escapeY = (Math.random() < 0.5 ? 1 : -1);
                } else {
                    if (Math.abs(dx) > Math.abs(dy)) {
                        escapeX = dx > 0 ? 1 : -1;
                    } else {
                        escapeY = dy > 0 ? 1 : -1;
                    }
                }

                // Multi-tile jump
                let jumpDist = 1;
                if (panic || Math.random() < CONFIG.PREY_MULTI_JUMP_CHANCE) {
                    jumpDist = 2;
                }

                let newX = food.x + escapeX * jumpDist;
                let newY = food.y + escapeY * jumpDist;

                // Try the jump position
                if (isValidFoodPosition(newX, newY)) {
                    food.x = newX;
                    food.y = newY;
                    foodEscapeCooldown = CONFIG.PREY_COOLDOWN;
                    spawnParticles(food.x, food.y, 'rgba(255, 200, 0, 0.5)', 3);
                } else {
                    // Try single tile
                    newX = food.x + escapeX;
                    newY = food.y + escapeY;
                    if (isValidFoodPosition(newX, newY)) {
                        food.x = newX;
                        food.y = newY;
                        foodEscapeCooldown = CONFIG.PREY_COOLDOWN;
                    } else {
                        // Try perpendicular
                        const perpX = escapeY !== 0 ? (Math.random() < 0.5 ? 1 : -1) : 0;
                        const perpY = escapeX !== 0 ? (Math.random() < 0.5 ? 1 : -1) : 0;
                        newX = food.x + perpX;
                        newY = food.y + perpY;
                        if (isValidFoodPosition(newX, newY)) {
                            food.x = newX;
                            food.y = newY;
                            foodEscapeCooldown = CONFIG.PREY_COOLDOWN;
                        }
                    }
                }
            }

            function spawnFood() {
                // Try near waste first
                if (wasteObstacles.length > 0 && Math.random() < CONFIG.FOOD_ATTRACT_CHANCE) {
                    const waste = wasteObstacles[Math.floor(Math.random() * wasteObstacles.length)];
                    for (let i = 0; i < 15; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = 2 + Math.floor(Math.random() * CONFIG.NUTRIENT_RADIUS);
                        const x = waste.x + Math.round(Math.cos(angle) * dist);
                        const y = waste.y + Math.round(Math.sin(angle) * dist);
                        if (isValidFoodPosition(x, y)) {
                            food = { x, y };
                            foodPanic = 0;
                            return;
                        }
                    }
                }

                // Random position
                for (let i = 0; i < 100; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * (dishRadius - 3);
                    const x = Math.floor(centerX + Math.cos(angle) * dist);
                    const y = Math.floor(centerY + Math.sin(angle) * dist);
                    if (isValidFoodPosition(x, y)) {
                        food = { x, y };
                        foodPanic = 0;
                        return;
                    }
                }
            }

            function isValidFoodPosition(x, y) {
                const dist = Math.sqrt(Math.pow(x - centerX + 0.5, 2) + Math.pow(y - centerY + 0.5, 2));
                if (dist >= dishRadius - 1) return false;

                for (const seg of snake) {
                    if (seg.x === x && seg.y === y) return false;
                }
                for (const waste of wasteObstacles) {
                    if (waste.x === x && waste.y === y) return false;
                }
                return true;
            }

            function spawnParticles(gridX, gridY, color, count) {
                const px = (gridX + 0.5) * CONFIG.TILE_SIZE;
                const py = (gridY + 0.5) * CONFIG.TILE_SIZE;

                for (let i = 0; i < count && particles.length < CONFIG.MAX_PARTICLES; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 1.5 + Math.random() * 4;
                    particles.push({
                        x: px,
                        y: py,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: color,
                        size: 2 + Math.random() * 5,
                        life: CONFIG.PARTICLE_LIFETIME
                    });
                }
            }

            // -----------------------------------------
            // RENDERING
            // -----------------------------------------
            function renderLoop(timestamp) {
                const deltaTime = timestamp - (renderLoop.lastTime || timestamp);
                renderLoop.lastTime = timestamp;

                if (isPlaying) update(deltaTime);

                // Update ambient particles
                updateAmbientParticles(deltaTime);

                render();
                requestAnimationFrame(renderLoop);
            }

            function updateAmbientParticles(dt) {
                const cx = gameWidth / 2;
                const cy = gameHeight / 2;
                const maxDist = dishRadius * CONFIG.TILE_SIZE * 0.95;

                ambientParticles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.pulse += dt / 1000;

                    // Keep in bounds
                    const dist = Math.sqrt(Math.pow(p.x - cx, 2) + Math.pow(p.y - cy, 2));
                    if (dist > maxDist) {
                        const angle = Math.atan2(p.y - cy, p.x - cx);
                        p.x = cx + Math.cos(angle) * maxDist * 0.9;
                        p.y = cy + Math.sin(angle) * maxDist * 0.9;
                        p.vx = -p.vx;
                        p.vy = -p.vy;
                    }
                });
            }

            function render() {
                // Apply screen shake
                ctx.save();
                if (screenShake > 0.5) {
                    ctx.translate(
                        (Math.random() - 0.5) * screenShake,
                        (Math.random() - 0.5) * screenShake
                    );
                }

                // Clear
                ctx.fillStyle = '#0a0f18';
                ctx.fillRect(0, 0, gameWidth, gameHeight);

                // Ambient glow
                const ambientGlow = ctx.createRadialGradient(
                    gameWidth / 2, gameHeight / 2, 0,
                    gameWidth / 2, gameHeight / 2, gameWidth / 2
                );
                ambientGlow.addColorStop(0, 'rgba(0, 50, 80, 0.1)');
                ambientGlow.addColorStop(0.5, 'rgba(0, 30, 50, 0.05)');
                ambientGlow.addColorStop(1, 'transparent');
                ctx.fillStyle = ambientGlow;
                ctx.fillRect(0, 0, gameWidth, gameHeight);

                drawGrid();
                drawAmbientParticles();
                drawWaste();
                drawSnakeTrail();
                drawFood();
                drawSnake();
                drawParticles();
                drawPetriMask();

                ctx.restore();
            }

            function drawGrid() {
                ctx.strokeStyle = 'rgba(20, 30, 50, 0.4)';
                ctx.lineWidth = 1;

                for (let x = 0; x <= gridWidth; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * CONFIG.TILE_SIZE, 0);
                    ctx.lineTo(x * CONFIG.TILE_SIZE, gameHeight);
                    ctx.stroke();
                }
                for (let y = 0; y <= gridHeight; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * CONFIG.TILE_SIZE);
                    ctx.lineTo(gameWidth, y * CONFIG.TILE_SIZE);
                    ctx.stroke();
                }
            }

            function drawAmbientParticles() {
                ambientParticles.forEach(p => {
                    const pulseAlpha = p.alpha * (0.7 + Math.sin(p.pulse * 2) * 0.3);
                    ctx.globalAlpha = pulseAlpha;
                    ctx.fillStyle = '#4488aa';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }

            function drawPetriMask() {
                ctx.save();
                ctx.globalCompositeOperation = 'destination-in';
                ctx.beginPath();
                ctx.arc(gameWidth / 2, gameHeight / 2, gameWidth / 2 - 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            function drawSnakeTrail() {
                snakeTrail.forEach((t, i) => {
                    const px = (t.x + 0.5) * CONFIG.TILE_SIZE;
                    const py = (t.y + 0.5) * CONFIG.TILE_SIZE;
                    const alpha = 0.15 * (1 - i / CONFIG.TRAIL_LENGTH);
                    const size = CONFIG.TILE_SIZE * 0.3 * (1 - i / CONFIG.TRAIL_LENGTH);

                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#00ffaa';
                    ctx.beginPath();
                    ctx.arc(px, py, size, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }

            function drawSnake() {
                const now = performance.now();
                const isFrenzy = hunger >= CONFIG.FRENZY_THRESHOLD;
                const isStarving = hunger > 60;
                const isSatiated = hunger < 30;

                const baseThickness = CONFIG.TILE_SIZE * 0.75;
                let thickness = baseThickness;
                if (isStarving) {
                    thickness = baseThickness * (0.55 + Math.sin(now / 40) * 0.1);
                } else if (isSatiated) {
                    thickness = baseThickness * (1.15 + Math.sin(now / 180) * 0.08);
                }

                // Draw from tail to head
                for (let i = snake.length - 1; i >= 0; i--) {
                    const seg = snake[i];
                    const px = (seg.x + 0.5) * CONFIG.TILE_SIZE;
                    const py = (seg.y + 0.5) * CONFIG.TILE_SIZE;

                    let bulge = 1;
                    for (const d of digestionQueue) {
                        if (Math.floor(d.progress) === i) {
                            bulge = 1.4 - Math.abs(d.progress - Math.floor(d.progress) - 0.5) * 0.8;
                        }
                    }

                    const taper = 1 - (i / snake.length) * 0.4;
                    const segThickness = thickness * bulge * taper;

                    // Color
                    let hue, sat, light;
                    if (isFrenzy) {
                        hue = 0;
                        sat = 80 - (i / snake.length) * 20;
                        light = 60 - (i / snake.length) * 15;
                    } else if (isStarving) {
                        hue = 140 + (i / snake.length) * 20;
                        sat = 70 - (i / snake.length) * 20;
                        light = 55 - (i / snake.length) * 15;
                    } else {
                        hue = 155;
                        sat = 100 - (i / snake.length) * 30;
                        light = 55 - (i / snake.length) * 15;
                    }
                    const color = `hsl(${hue}, ${sat}%, ${light}%)`;

                    // Glow
                    const glowGrad = ctx.createRadialGradient(px, py, 0, px, py, segThickness * 1.5);
                    glowGrad.addColorStop(0, color);
                    glowGrad.addColorStop(0.5, color);
                    glowGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = glowGrad;
                    ctx.beginPath();
                    ctx.arc(px, py, segThickness * 1.5, 0, Math.PI * 2);
                    ctx.fill();

                    // Core
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(px, py, segThickness / 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Head details
                    if (i === 0) {
                        // Inner highlight
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                        ctx.beginPath();
                        ctx.arc(px - segThickness * 0.15, py - segThickness * 0.15, segThickness * 0.18, 0, Math.PI * 2);
                        ctx.fill();

                        // Eyes
                        const eyeOffset = segThickness * 0.22;
                        const eyeSize = segThickness * 0.14;
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(
                            px + direction.x * eyeOffset + direction.y * eyeOffset * 0.6,
                            py + direction.y * eyeOffset - direction.x * eyeOffset * 0.6,
                            eyeSize, 0, Math.PI * 2
                        );
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(
                            px + direction.x * eyeOffset - direction.y * eyeOffset * 0.6,
                            py + direction.y * eyeOffset + direction.x * eyeOffset * 0.6,
                            eyeSize, 0, Math.PI * 2
                        );
                        ctx.fill();

                        // Eye shine
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.beginPath();
                        ctx.arc(
                            px + direction.x * eyeOffset + direction.y * eyeOffset * 0.6 - eyeSize * 0.3,
                            py + direction.y * eyeOffset - direction.x * eyeOffset * 0.6 - eyeSize * 0.3,
                            eyeSize * 0.35, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
            }

            function drawFood() {
                if (!food) return;

                const px = (food.x + 0.5) * CONFIG.TILE_SIZE;
                const py = (food.y + 0.5) * CONFIG.TILE_SIZE;
                const now = performance.now();

                const basePulse = 1 + Math.sin(now / 120) * 0.15;
                const panicPulse = foodPanic > 0 ? (1 + Math.sin(now / 30) * 0.2 * foodPanic) : 1;
                const pulse = basePulse * panicPulse;

                const baseSize = CONFIG.TILE_SIZE * 0.4;
                const size = baseSize * pulse;

                // Panic shake
                let offsetX = 0, offsetY = 0;
                if (foodPanic > 0) {
                    offsetX = (Math.random() - 0.5) * 4 * foodPanic;
                    offsetY = (Math.random() - 0.5) * 4 * foodPanic;
                }

                const fx = px + offsetX;
                const fy = py + offsetY;

                // Outer glow
                const glowGrad = ctx.createRadialGradient(fx, fy, 0, fx, fy, size * 3);
                glowGrad.addColorStop(0, 'rgba(255, 200, 0, 0.5)');
                glowGrad.addColorStop(0.3, 'rgba(255, 150, 0, 0.25)');
                glowGrad.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGrad;
                ctx.beginPath();
                ctx.arc(fx, fy, size * 3, 0, Math.PI * 2);
                ctx.fill();

                // Cell membrane
                const bodyGrad = ctx.createRadialGradient(fx - size * 0.25, fy - size * 0.25, 0, fx, fy, size);
                bodyGrad.addColorStop(0, '#ffee99');
                bodyGrad.addColorStop(0.4, '#ffcc00');
                bodyGrad.addColorStop(1, '#ee9900');
                ctx.fillStyle = bodyGrad;
                ctx.beginPath();
                ctx.arc(fx, fy, size, 0, Math.PI * 2);
                ctx.fill();

                // Nucleus
                ctx.fillStyle = 'rgba(200, 100, 0, 0.6)';
                ctx.beginPath();
                ctx.arc(fx + size * 0.1, fy + size * 0.1, size * 0.4, 0, Math.PI * 2);
                ctx.fill();

                // Specular
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(fx - size * 0.3, fy - size * 0.3, size * 0.25, 0, Math.PI * 2);
                ctx.fill();

                // Panic indicator
                if (foodPanic > 0.3) {
                    ctx.strokeStyle = `rgba(255, 100, 100, ${foodPanic * 0.5})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.arc(fx, fy, size * 1.8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            function drawWaste() {
                const now = performance.now();

                wasteObstacles.forEach(waste => {
                    const px = (waste.x + 0.5) * CONFIG.TILE_SIZE;
                    const py = (waste.y + 0.5) * CONFIG.TILE_SIZE;
                    const size = CONFIG.TILE_SIZE * 0.42 * waste.scale;

                    const baseColor = waste.toxic ? '#cc44ff' : '#445566';
                    const glowColor = waste.toxic ? 'rgba(200, 100, 255, 0.3)' : 'rgba(70, 90, 110, 0.2)';

                    // Nutrient aura
                    if (waste.scale > 0.5) {
                        const auraGrad = ctx.createRadialGradient(px, py, size, px, py, CONFIG.NUTRIENT_RADIUS * CONFIG.TILE_SIZE);
                        auraGrad.addColorStop(0, glowColor);
                        auraGrad.addColorStop(1, 'transparent');
                        ctx.fillStyle = auraGrad;
                        ctx.beginPath();
                        ctx.arc(px, py, CONFIG.NUTRIENT_RADIUS * CONFIG.TILE_SIZE, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Body
                    const bodyGrad = ctx.createRadialGradient(px, py, 0, px, py, size);
                    bodyGrad.addColorStop(0, baseColor);
                    bodyGrad.addColorStop(1, waste.toxic ? '#8822cc' : '#334455');
                    ctx.fillStyle = bodyGrad;
                    ctx.beginPath();
                    ctx.arc(px, py, size, 0, Math.PI * 2);
                    ctx.fill();

                    // Texture blobs
                    ctx.globalAlpha = 0.4;
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2 + now / 5000;
                        const bx = px + Math.cos(angle) * size * 0.5;
                        const by = py + Math.sin(angle) * size * 0.5;
                        ctx.fillStyle = waste.toxic ? '#6611aa' : '#223344';
                        ctx.beginPath();
                        ctx.arc(bx, by, size * 0.22, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;
                });
            }

            function drawParticles() {
                particles.forEach(p => {
                    const alpha = p.life / CONFIG.PARTICLE_LIFETIME;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }

            // -----------------------------------------
            // HUD
            // -----------------------------------------
            function updateHUD() {
                document.getElementById('score-display').textContent = score;
                document.getElementById('length-display').textContent = snake.length;

                const hungerBar = document.getElementById('hunger-bar');
                hungerBar.style.width = hunger + '%';

                const statusEl = document.getElementById('hunger-status');
                if (hunger >= CONFIG.FRENZY_THRESHOLD) {
                    statusEl.textContent = 'FRENZY';
                    statusEl.style.color = '#ff4444';
                    statusEl.style.textShadow = '0 0 10px rgba(255, 68, 68, 0.8)';
                } else if (hunger > 60) {
                    statusEl.textContent = 'Starving';
                    statusEl.style.color = '#ff8844';
                    statusEl.style.textShadow = 'none';
                } else if (hunger < 30) {
                    statusEl.textContent = 'Satiated';
                    statusEl.style.color = '#44ff88';
                    statusEl.style.textShadow = 'none';
                } else {
                    statusEl.textContent = 'Balanced';
                    statusEl.style.color = '#556688';
                    statusEl.style.textShadow = 'none';
                }
            }

            // -----------------------------------------
            // START
            // -----------------------------------------
            document.addEventListener('DOMContentLoaded', init);
        })();
    </script>
</body>
</html>
